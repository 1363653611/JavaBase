观察者设计模式：
 一个被观察这管理所有相依于它的观察者物件，并且自身的状态发生改变时，主动发出通知。这通常通过呼叫各个观察者
 所提供的方法来实现，此模式通常被用来实现事件处理系统
 角色：
 	抽象被观察这角色：把所有观察者对象的引用都存在一个集合中，每个被观察者可以有任意数量的观察者。
 	被观察者提供一个接口，可以增加和删除观察者角色，一般用抽象类和接口来实现
 	
 	具体的被观察这角色：在被观察者内部的状态改变时，给所有登记过的观察者发出通知。具体被观察者角色通常用于一个子类的实现
 	
 	抽象观察者角色：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己
	具体的观察者角色：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。
	如果需要，具体观察者角色可以保存一个之下你个具体主题角色的引用
	
	适用场景：
		1.当一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这二者封装在对立的对象中，以使他们可以各自独立的改变和
		复用
		2.当对一个对象的改变要同时改变其他对象，而不知道具体有多少对象改变
		3.当一个对象必须通知其他对象，而它又不能假定其他对象是谁。换而言之，你不希望对象是紧密耦合的
		
		我推你拉
	例子中没有关于数据和状态的变化通知，只是简单通知到各个观察者，告诉他们被观察者有行动。
	观察者模式在关于目标角色、观察者角色通信的具体实现中，有两个版本。
	一种情况便是目标角色在发生变化后，仅仅告诉观察者角色“我变化了”，观察者角色如果想要知道具体的变化细节，则就要自己从目标角色的接口中得到。
	这种模式被很形象的称为：拉模式——就是说变化的信息是观察者角色主动从目标角色中“拉”出来的。
	还有一种方法，那就是我目标角色“服务一条龙”，通知你发生变化的同时，通过一个参数将变化的细节传递到观察者角色中去。
	这就是“推模式”——管你要不要，先给你啦。
	这两种模式的使用，取决于系统设计时的需要。如果目标角色比较复杂，并且观察者角色进行更新时必须得到一些具体变化的信息，则“推模式”比较合适。
	如果目标角色比较简单，则“拉模式”就很合适啦。
		
		