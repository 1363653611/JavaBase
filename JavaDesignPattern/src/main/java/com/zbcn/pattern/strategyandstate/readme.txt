策略模式和状态模式在实现上有共同之处，都是把不同的情形抽象为统一的接口来实现。就是放在一起进行记录。
唯一的区别是在子类实现与context相关的一个状态行为。

状态模式的思想是：状态之间的切换，在状态A执行完毕后，自己控制指向B，状态模式是不断的切换状态来执行。

策咯模式的思想是：考虑多种不同的物业规则的算法封装起来，便于调用者选择调用，策咯模式是条件选择执行一次

策略模式：
	1.Strategy：定义所有支持算法的公共接口抽象类
	2.ConcreteStrategy：封装了具体的算法或者行为，用于集成Strategy
	3.Context：用一个ConcreteStrategy来配置，维护一个对Strategy 对象的引用
	
状态模式：
	1.state：抽象的状态类，定义一个接口以封装与context的状态相关的行为
	2.concreteState：具体状态，每个子类实现一个与Context的一个状态相关的行为
	3.Context：维护一个ConcreteState子类的实例，这个实例定义当前的状态
	
使用场景：
	状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂的情况。把状态的逻辑判断转移
	到不同状态的一些列类当中。可以把复杂的逻辑判断简化。当一个对象的行为取决于他的状态时，并且必须在
	运行时根据状态改变他的行为时，就可以使用状态模式了。
	
	策略模式的Stragegy类层次为context定义了一系列可供重用的算法或行为。继承有助于取出这些算法中的
	公共功能。在实践中，我们发现可以用它来封装几乎任何类型的规则。只要在分析过程中，发现需要在不同的时间
	应用不同的业务规则。可以考虑使用策略模式处理这种变化的可能性。
	
策略模式和状态模式的比较：
	两个模式的实现类图虽然一致，但是实现目标却不一样。
	1.策略模式是一个接口的应用案例，一个很重要的设计模式，简单易用。一般用于单个算法的替换，客户段必须知道
	所有的可替换的策略。由客户端去指定环境需要哪个策略，注意通常都是只有一个最恰当的策略被选择。其他的策略是
	同级的，可以动态的在运行中替换原有的策略。
	2.状态模式的每个状态子类中需要包含环境类（context）中的所有方法的具体实现---条件语句。通过吧行为和行为
	对应的逻辑包装到状态类里，在环境类中消除了大量的判断逻辑，而不同状态的切换有继承（实现）state状态的子类去实现，
	当发现修改的当前对象的状态不是自己这个状态所对应的参数，则各个状态子类自己给context切换状态（有责任连模式的思想），
	且客户端不直接和状态类交互，客户端不需要了解状态！（和策咯模式不一样），策咯模式是直接依赖注入到context类的参数进行
	选择策略，不存在切换状态的操作，客户端需要了解策略。
	
	联系：状态模式和策略模式都是为具有多种可能情形的设计的模式，把不同的处理情形抽象为一个相同的接口（抽象类）。符合开闭原则。
	且策咯模式更具有一般性，在实践中，可以用策略模式是来封装几乎任何类型的规则，只要在分析过程中听到在不同实践应用不同的业务股规则，
	就可以考虑使用策略模式去处理，在这一点上，策略模式是包含状态模式的
	
	状态模式的使用场景：
		状态模式主要解决的是（目的或者意图）：控制一个对象内部的状态转换的条件表达式过于复杂时的情况，且客户端调用之前不需要了解具体
		状太，它把状态的判断逻辑转到表现不同状态的一些列类当中，可以吧复杂的判断逻辑简化。维持开闭原则，方便维护
		
		注意：状态模式是让各个抓鬼太对象自己知道其下一个处理的对象是谁，即在状态子类在编译时在代码上就设定好了。
	
	状态模式的优点：
		1.状态模式使得代码中复杂而庸长的逻辑判断语句问题得到了解决，而且状态角色将具体的状态和他对应的行为及逻辑判断封装了起来，这使得
		增加一种新的状态显得十分简单。
		2.使得容易出错的if-else 语句在环境类中或者客户端中消除，方便维护。
		3.每一个状态类都符合“开闭原则”--对状态的修改关闭，对客户端的拓展开放，可以随时增加或者删除对应的person的状态。
		4.state类只有行为需要抽象时，就用接口，有其他共同功能可以用抽象类，这点和其他一些模式（策略）类似。
		
	状态模式缺点：
		使用状态模式时，没个状态对应一个具体的状态类，结构分散，使类变得很多。使得结构变得稍微复杂，阅读代码时相对之前比较困难，
		不过对于优秀的研发人员来说，应该是微不足道的。因为想要获得弹性，就必须付出代价。除非我们的程序是一次性的！用完就丢掉……如果不是，那么假设有一个系统，
		某个功能需要很多状态，如果不使用状态模式优化，那么在环境类（客户端类）里会有大量的整块整块的条件判断语句！


	Strategy模式的优点：
		1.相关的算法系列Strategy 类层次为Context定义了一系列的可供重用的算法或者行为。继承有助于取出这些算法中的公共功能。
		2.提供了可以替换继承关系的办法：继承提供了另一种支持多种算法或者行为的方法。你可以直接生成一个Context类的子类，从而给它以不同的行为。但这样
		会将行为硬编码到context类中，而将算法的实现与context的实现混合起来，从而使得context难以理解\难以维护\难以扩展,而且含不能动态的改变算法.
		最后你将会得到一堆相关 的类,他们之间的唯一差别就是他们所使用的算法或者行为.将算法封装在独立的strategy类中,使得你可以独立于其context而改变他,使得
		它易于切换,理解和扩展.
		3.消除了一些if-else的条件语句:Strategy模式提供了条件语句选择所需的行为之外的另外一种选择.当不同的行为堆砌到一个类中时,很难避免用条件语句来选择
		合适的行为.将行为封装在一个个独立的strategy类中,消除了这些条件语句.含有许多条件语句的代码通常都意味着需要使用策略模式.
		4.实现的选择strategy模式可以提供相同行为的不同实现,客户可以更具不同时间/空间权衡取舍要求从不同的策略中进行选择.
	
	Strategy模式的缺点:
		1.客户端必须知道所有的策略类,并且自行确定使用哪个策略类:该模式有一个潜在的缺点,就是一个酷虎需要选择一个合适的Stragegy就必须知道这些Stragegy到底有何
		不同,此时不得不和客户端暴露具体实现为题.因此仅当这些不同的行为变体于客户相关的行为时,才需要使用Stragegry模式
		2.Stragegry和context之间的通讯开销:无论各个concreteStragegry实现的算法是简单还是复杂,他们都共享strategy定义的接口.因此很可能某些concreteStragegry都不会
		用到所有通过这个接口传递给他们的信息,简单的ConcreteStragegry可能不使用其中的任何信息!这就意味着有时context会初始化和创建一些永远不会用到的参数.如果存在这样问题,那么将要
		在Strategry和context之间进行更紧密的耦合.
		3.策略模式将造成产生很多策略类:可以通过使用享元模式在硬顶程度上减少对象数量.增加了对象数目Stragegry增加了一个应用中的对象数目.有时你可以将stragegry实现为可供各context共享
		无状态对象来减少这一开销.任何剩余的状态都由context维护.context在每一次对strategy对象的请求中都将这个状态太传递过去,共享的stragegry不应该在各次调用之间维护.
	
	
	
	
	
	
	
	
	
	
	
	
	
		
