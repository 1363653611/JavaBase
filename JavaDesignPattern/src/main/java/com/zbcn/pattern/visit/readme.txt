访问者模式：
	封装某些作用于某种数据结构中各元素的操作，
	它可以在不改变数据结构的前提下定义作用于这些元素的新的操作
角色：
	抽象的访问者：抽象类或者接口，申明访问者可以访问那些元素，具体到程序中就是visit方法中的参数定义那些对象是可以被访问的
	访问者：实现抽象访问者所申明的方法，他影响到访问者访问到一个类后该干什么，要做什么事情。
	抽象元素类：接口或者抽象类，申明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法：
	1.业务本身的逻辑，2.允许接受那一类访问者来访问
	元素类：实现抽象元素类所申明的accept方法，通常都是visitor.visit(this),基本上形成一种定式了。
	结构对象：
	一个元素的容器，一般包含一个容纳多个不同的类，不同接口的容器，如list，set，map等，在项目中一般很少抽出这个角色。
	
	优点：
	符合单一职责原则：凡是适用访问者模式的场景中，元素类中需要封装在访问者中的操作必定是于元素类本身关系不大且异变的操作，适用访问
	者模式一方面符合单一职责原则，另一方面，应为被封装的操作通常来说都是易变的，所以当发生变化时，姐可以在不改变元素类本身的前提下，
	实现对变化部分的拓展。
	
	拓展性良好：元素类可以通过接受不同的访问者来实现不同操作的扩展
	
	缺点：
	新增加元素较困难，通过访问者模式的代码可以看到，在访问者类中，每个元素都有它对应的处理方法，也就是说，每增加一个元素，都要修改
	访问者类（也包括访问者类的子类或者实现者类），修改起来是相当麻烦的。即，在元素数目不确定的情况下，需要慎用访问者模式。
	
	访问者模式比较适用于对已有功能的重构，比如说，一个项目的基本功能已经确定下来，元素的数据已经基本确定下来不会变了，会变的只是
	这些元素的相关操作。这时候，我可以用访问者模式对原有的代码进行重构一遍，这样一来，就可以在不修改元素类的情况下，对原有的功能
	进行修改。
	
	适用场景：
		假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染对象，则可以适用访问者模式来把这些操作
		封装在访问者中去。
		假如一组对象中，存在着相似的操作，为了避免大量出现重复的代码，也可以将这些重复的操作封装到访问者中去。